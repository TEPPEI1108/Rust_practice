🔍 結論から言うと：

print! は 改行しない出力 なので、
出力がバッファにたまったまま、まだ画面に表示されていない 状態になることがあります。

一方、println! は 改行付きの出力 なので、
改行文字（\n）を出力した時点で 自動的にバッファがフラッシュ（画面に反映） されます。

💡 詳しく説明

Rustの標準出力（stdout）は、行バッファリング（line-buffered） という仕組みになっています。

出力先	バッファリングの種類	いつ画面に出るか
端末（ターミナル）	行バッファリング	改行 \n が出たとき、またはフラッシュされたとき
ファイルやパイプ	全バッファリング	バッファがいっぱいになったとき or 明示的にフラッシュされたとき
🧠 つまりこういうことです

あなたのコードでは、たとえば：

print!("Please input your guess : ");


とした場合、改行がないので、
Rustは「まだ行が終わっていない」と判断して、
ユーザーが入力を終えるまで実際の出力を保留 してしまいます。

✅ 対策（print!を使いたい場合）

stdoutを手動で**フラッシュ（flush）**すればOKです👇

use std::io::{self, Write}; // Writeトレイトをインポート！

fn main() {
    print!("Please input your guess: ");
    io::stdout().flush().unwrap(); // フラッシュして即座に出力
}


こうすると、改行なしでもすぐに表示されます。

💬 まとめ
状況	動作
println!()	改行あり → 自動で出力される
print!()	改行なし → バッファに溜まり、後でまとめて表示される
print!() + io::stdout().flush().unwrap()	改行なしでも即時表示される ✅
💡補足

これはRustに限らず、
C言語（printf）やPython（print(..., end='')）なども同じような仕組みを持っています。
改行がないと出力が遅れるのは、「効率化のためのバッファリング」 が原因です。